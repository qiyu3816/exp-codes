# 实验三 遗传算法VS回溯法

### 姓名： 梁芮槐     学号：2019302789  班级：14011907

### 一、问题描述

​	回溯法可以处理货郎担问题，遗传算法也可以处理货郎担问题，回溯法和遗传算法哪个算法处理货郎担问题效率更高呢？在相同计算时间内，哪个算法得到的解更好呢？

​	实现遗传算法，通过随机产生10个不同规模的算例（城市数量分别为10，20，40，80，100，120，160，180，200，500，或者其它规模），比较上次实验实现的回溯法和遗传算法。

### 二、实验目的及要求

1. 理解遗传算法思想，并实现遗传算法；

2. 掌握不同的参数和遗传操作（选择、交叉、变异）的优缺点；

3. 比较遗传算法和回溯法的执行效率，分析遗传算法和回溯法的优缺点。

### 三、算法伪代码或流程图

```flow
st=>start: 随机生成n个城市的图
op1=>operation: 随机产生规模为initPopulationNum()的初始群体，生成过程中个体用repair()个体基因修复进行检验，生成的个体互相不一样
cond1=>condition: 是否完成generation代循环？

op2=>operation: CalcFitness()计算个体适应度值
op3=>operation: GambleSelect()轮盘赌选择运算，随机生成0-1小数，决定当前选中的个体
op4=>operation: Hybridization()单点交叉运算，根据交叉概率hybridizationFactor决定是否交叉，随机选择交叉点，交叉后repair()修复个体基因
op5=>operation: Mutation()基本为变异，根据变异概率mutationFactor决定是否变异，随机选择变异位

op6=>operation: 遍历最后一代，选择cost最小的解

e=>end: 输出最终解

st->op1->cond1
cond1(yes)->op6->e
cond1(no)->op2->op3->op4->op5->cond1
```



### 四．算法时间复杂性分析

​	若对于个体基因长度n，规模为p的种群，进行m代遗传：

​	首先，随机生成初始种群，p个个体，生成每个个体基因的操作复杂度$O(n)$，平均每个个体的修复操作的复杂度时$O(\frac{n}{2})$，最终为$O(pn)$。

​	然后计算个体适应度，每个个体用$O(n)$计算个体适应度，再花一个$O(n)$生成轮盘，最终$O(pn)$。

​	再进行轮盘赌选择，遍历和替换共$O(2p)$，最终$O(p)$。

​	交叉操作，$\frac{p}{2}$轮遍历，$\frac{p}{2}*hybridizationFactor$轮需要交叉，交叉操作加上交叉后的修复平均复杂度$O(n)$，最终$O(pn)$。

​	变异操作，$p$轮遍历，$p*mutationFactor$轮需要变异，变异操作复杂度$O(1)$，最终$O(p)$。

​	循环m代，每代$O(pn)$，**最终**$O(mpn)$。

### 五．实验结果与分析

<img src="GA1.jpg" style="zoom:50%;" />

<img src="GA2.jpg" style="zoom:50%;" />

遗传算法运行效率比DFS和BFS可以说是极快，但求出的解并非最优解甚至会与最优解有很大偏差。

<img src="GA_10cities_34.jpg" style="zoom:67%;" />

10个城市，用DFS得出最优解为34，但遗传算法经过一系列调参也只能做到有时逼近最优解的程度。

### 六．问题思考与总结

​	遗传算法相比DFS和BFS优势在于运行速度快很多，可以在一定时间内给出可以接受的解，但因为基于概率进行每一轮筛选，所以调试时难以了解程序运行的过程，调参困难。遗传算法得出的是根据概率解算的尽最大努力交付的最优解，和真实最优解有一定差距。