# 实验一 动态规划算法

**姓名：** 梁芮槐    **学号：** 2019302789      **班级：**  14011907

**一．问题描述**

小明想要在王者荣耀游戏里晋升一个段位，假设他一共需打了*n*场比赛，且必须成功赢得至少70%的场次才能成功晋升。假设每场比赛小明获胜的概率分别为*p*1，*p*2，…，*pn*，请帮他算出成功晋级段位的概率是多少？

输入：
   参数1：整数num（0 £ num £ 1000），表示比赛的场数。

参数2：整数数组*p*[num] = {*p*1，*p*2，…，*pnum*}，其中*pi*表示小明有*pi*%的概率赢得第*i*场比赛。（0 £ *pi* £ 100）

输出：

成功晋级段位的概率，保留小数点后5位，最后结果四舍五入。

**二．实验目的及要求**

1.理解动态规划法的设计思想

2.掌握动态规划法的求解步骤

3.掌握用动态规划法解题的算法框架

**三．实验分析**

   首先令m为最小需要赢的局数为0.7n向上取整，求至少赢得m局的概率。

   根据动态规划的思想，令p[i]为第i局获胜的概率，设dp[i][j]为前i局赢j局的概率，第i局赢则dp[i][j]=p[i]*dp[i-1][j-1]，第i局输则dp\[i][j]=(1.0-p[i])*dp\[i-1][j]，因而有状态转移方程：

   dp\[i][j]= p[i]\*dp\[i-1][j-1] +(1.0-p[i])\*dp\[i-1][j]

   然后得到一个复杂度$O(n^2)$，由于dp\[i][j]只从dp\[i-1][j]和dp\[i-1][j-1]转移得到，因而可以从j=n开始回推，从而得出新的前i局的状态，并将dp降维至一维，降低空间复杂度。

**四．算法伪代码或流程图**

伪代码：

```
dp[1...n] = 0
dp[0] = 1
res = 0
for i in [1...n]:
	for j in [n...1]:
		dp[j] = dp[j - 1] * p[i] + dp[j] * (1 - p[i])
	dp[0] = dp[0] * (1 - p[i])
for i in [ceil(0.7 * n)...n]: res += dp[i]
```

 C++实现：

```c++
#include <iostream>
#include <vector>
#include <iomanip>

using namespace std;

int n;

void ProbabilityToPromote()
{
    int m = n * 0.7 + ((n % 10) == 0 ? 0 : 1);
    vector<double> p(n + 1), dp(n + 1);
    dp[0] = 1;
    for (int i = 1; i <= n; i++)
    {
    	cin >> p[i];
    	p[i] /= 100.0;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = n; j > 0; j--)
        {
            dp[j] = dp[j - 1] * p[i] + dp[j] * (1.0 - p[i]);
        }
        dp[0] *= (1.0 - p[i]);
    }
    double res = 0;
    // 至少赢m局的情况概率相加
    for (int i = m; i <= n; i++) res += dp[i];
    cout << setprecision(5) << res;
}
int main()
{
    cin >> n;
	ProbabilityToPromote();
    return 0;
}

```

**五．算法时间复杂性分析**

 	本题解法执行n(n+1)次代价为$O(1)$的操作进行状态转移，最后执行n-0.7n+1（0.7n向取整）次代价$O(1)$的累加操作统计所有满足条件的情况，时间复杂度$O(n^2)$。

**八．问题思考与总结**

 	根据题意设计的动态规划转移方程，与01背包问题的解法类似，可以类比解决。

**九．实验中出现的问题及总结**

 	无。

 